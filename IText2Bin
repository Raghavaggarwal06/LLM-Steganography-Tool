"""
Utilities for compressing text with llama-zip.
"""

from __future__ import annotations

import base64
import binascii
import os
import subprocess
from typing import Optional

DEFAULT_N_CTX = 8192
DEFAULT_WINDOW = "25%"
DEFAULT_MODEL = "QK4M"


def _resolve_llama_zip_path(llama_zip_path: Optional[str]) -> str:
    return llama_zip_path or os.environ.get("LLAMA_ZIP_BIN", "llama-zip")


def _resolve_model(model: Optional[str]) -> str:
    return model or os.environ.get("LLAMA_ZIP_MODEL", DEFAULT_MODEL)


def _run_llama_zip(
    input_text: str,
    *,
    llama_zip_path: str,
    model: str,
    n_ctx: int,
    window: str,
) -> bytes:
    cmd = [
        llama_zip_path,
        "--model",
        model,
        "--n-ctx",
        str(n_ctx),
        "-w",
        window,
        "--base64",
    ]
    result = subprocess.run(
        cmd,
        input=input_text.encode("utf-8"),
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        check=False,
    )
    if result.returncode != 0:
        stderr = result.stderr.decode("utf-8", errors="replace").strip()
        raise RuntimeError(
            f"llama-zip failed with code {result.returncode}: {stderr}"
        )
    output = result.stdout
    if not output:
        raise RuntimeError("llama-zip returned empty output.")
    return output


def _decode_base64_output(b64_output: bytes) -> bytes:
    normalized = b"".join(b64_output.split())
    if not normalized:
        raise ValueError("llama-zip returned empty base64 output.")
    try:
        return base64.b64decode(normalized, validate=True)
    except binascii.Error:
        padding = b"=" * ((4 - len(normalized) % 4) % 4)
        try:
            return base64.b64decode(normalized + padding, validate=False)
        except binascii.Error as exc:
            raise ValueError("llama-zip output was not valid base64.") from exc


def _prepend_bit_length_header(payload: bytes) -> bytes:
    bit_length = len(payload) * 8
    if bit_length > 0xFF:
        raise ValueError(
            "Encoded bit length exceeds 255 bits; 8-bit header too small."
        )
    return bytes([bit_length]) + payload


def IText2Bin(
    input_text: str,
    *,
    llama_zip_path: Optional[str] = None,
    model: Optional[str] = None,
    n_ctx: int = DEFAULT_N_CTX,
    window: str = DEFAULT_WINDOW,
) -> bytes:
    """
    Compress input_text using llama-zip and return header + payload bytes.

    The output format is:
      [1 byte: length of payload in bits][payload bytes]
    """
    if not isinstance(input_text, str):
        raise TypeError("input_text must be a string.")
    llama_zip_path = _resolve_llama_zip_path(llama_zip_path)
    model = _resolve_model(model)

    b64_output = _run_llama_zip(
        input_text,
        llama_zip_path=llama_zip_path,
        model=model,
        n_ctx=n_ctx,
        window=window,
    )
    payload = _decode_base64_output(b64_output)
    if not payload:
        raise ValueError("llama-zip returned base64 that decoded to empty bytes.")
    return _prepend_bit_length_header(payload)
